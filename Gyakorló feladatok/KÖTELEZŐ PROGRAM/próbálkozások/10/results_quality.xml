<?xml version="1.0" encoding="UTF-8" standalone="no"?><results maxScore="6.67" score="6.546881"><qualitygroup groupMaxScore="1.2006" groupScore="1.3403722" name="Objektumorientáltság" weight="18.0"><metric hint="Ügyelj rá, hogy egy osztálynak pontosan egy feladata legyen és ne végezzen több különböző dolgot. Ha az osztály néhány metódusa az adattagok egy adott halmazát, míg néhány metódusa az adattagoknak egy másik halmazát használja, akkor azok mentén az osztály szétszedhető. Amennyiben azt tapasztalod, hogy az osztálynak több feladata is van, akkor bontsd szét az osztályt ezen feladatok mentén. (Lack of Cohesion in Methods 5)" maxScore="0.72036" metricName="LCOM5" name="Osztályok funkcionalitásai" score="0.90045005" weight="6.0"/><metric hint="Érdemes elkerülni a túl bonyolult osztályokat. Optimális esetben egy osztálynak nem kell, hogy túl sok adattagja legyen. Amennyiben azt tapasztaljuk, hogy egy osztálynak több, mint 15 adattagja van, akkor érdemes elgondolkozni az adattagok számának csökkentésén, amely történhet például öröklődéssel, vagy az összetartozó adatok (és műveletek) kiszervezésével. (Number of Local Attributes)" maxScore="0.120060004" metricName="NLA" name="Adattagok száma" score="0.12895338" weight="1.0"/><metric hint="Érdemes elkerülni a túl bonyolult osztályokat. Optimális esetben egy osztálynak nem kell, hogy túl sok metódusa legyen. Amennyiben azt tapasztaljuk, hogy egy osztálynak több, mint 25 metódusa van, akkor érdemes elgondolkozni a metódusok számának csökkentésén, amely történhet például öröklődéssel, vagy az összetartozó műveletek (és adatok) kiszervezésével. (Number of Local Methods)" maxScore="0.120060004" metricName="NLM" name="Metódusok száma" score="0.12895338" weight="1.0"/><metric hint="Az információ elrejtés elvét figyelembe véve optimális esetben egy osztálynak nincsen publikus adattagja. A publikus adattagokat bárki kívülről elérheti (és módosíthatja). Érdemes ehelyett a láthatóságát lekorlátozni és helyette getter illetve setter metódusok segítségével hozzáférést biztosítani (amennyiben szükséges). (Number of Local Public Attributes)" maxScore="0.120060004" metricName="NLPA" name="Publikus adattagok száma" score="0.056004666" weight="1.0"/><metric hint="Csak azokat a metódusokat célszerű publikussá tenni, amelyet tényleg el kell, hogy érjünk kívülről. Ha egy metódust csak az osztályon belülről (vagy csak a gyerekosztályban) használunk, akkor érdemes privátra vagy protectedre állítani a láthatóságát. (Number of Local Public Methods)" maxScore="0.120060004" metricName="NLPM" name="Publikus metódusok száma" score="0.1260105" weight="1.0"/></qualitygroup><qualitygroup groupMaxScore="1.2006" groupScore="1.0561833" name="Kódbonyolultság" weight="18.0"><metric hint="Nagyobb rendszerek elkészítésénél nagyon fontos a programkód karbantarthatósága, mert később már nem emlékszünk rá, hogy mit miért csináltunk vagy épp melyik programrész mit csinál. A karbantarthatóság javítására több eszköz is rendelkezésre áll. Egyrészt érdemes a metódusaink méretét csökkenteni, ugyanis a rövidebb metódusok jobban átláthatóak. Továbbá érdemes a metódusok bonyolultságát is csökkenteni például a beágyazási szintek csökkentésével, vagy egyes részfeladatok külön függvénybe szervezésével. Minél nagyobb a metrika értéke, annál karbantarthatóbb egy adott metódus. (Maintainability Index)" maxScore="0.34302858" metricName="MI" name="Karbantarthatóság" score="0.2708193" weight="4.0"/><metric hint="Ha egy függvény bonyolult, az sok problémát okoz. Így a függvény nehezebben lesz értelmezhető, karbantartható, ráadásul, ha nagyon sok különböző kimenetele lehet, akkor tesztelni is jóval körülményesebb és nagyobb odafigyelést igényel. Egy metódus komplexitása abból adódik, ha sok benne az olyan szerkezet, aminek hatására a lefutásnak különböző eredményei lehetnek (pl. feltételek, ciklus, try-catch szerkezetek), illetve ezek bonyolultsága nagy (pl. az ifben sok ÉS, VAGY művelet van). Ezek minimalizálásával a függvény egyszerűbbé tehető. Ügyeljünk a feltételek megfelelő kezelésére, illetve az egyes részfeladatokat érdemes lehet külön függvényekbe kiszervezni. (McCabe’s Cyclomatic Complexity)" maxScore="0.5145429" metricName="McCC" name="Kódbonyolultság" score="0.4302566" weight="6.0"/><metric hint="Ha egy függvényen belül nagy a beágyazottság (pl. if-en belül még egy if, azon belül egy for, azon belül még egy if...), akkor nagyon nehezen értelmezhető kódot kapunk. Érdemes tehát a beágyazottsági szintet csökkenteni. Ez megoldható a feltételek megfelelő összevonásával, vagy az egyes részfeladatok külön függvényekbe szervezésével. (Nesting Level)" maxScore="0.17151429" metricName="NL" name="Beágyazottság" score="0.1757679" weight="2.0"/><metric hint="Ha egy osztály nagyon hosszú, akkor nehezen átlátható. Érdemes tehát az osztály méretét csökkenteni. (Logical Lines of Code)" maxScore="0.085757144" metricName="LLOC" name="Osztályok tényleges sorainak száma" score="0.08910706" weight="1.0"/><metric hint="Ha egy metódus nagyon hosszú, akkor nehezen átlátható. Érdemes tehát a metódus méretét csökkenteni. (Logical Lines of Code)" maxScore="0.085757144" metricName="LLOC" name="Metódusok tényleges sorainak száma" score="0.09023255" weight="1.0"/></qualitygroup><qualitygroup groupMaxScore="1.2006" groupScore="1.2508346" name="Duplikátumok" weight="18.0"><metric hint="Optimális esetben a programunk nem tartalmaz duplikátumokat, azaz olyan részeket, amelyek úgy keletkeztek, hogy a program egy másik részéről másoltuk. Ha valamikor azt tapasztaljuk, hogy a programozás során egy kódrészletet úgy készítünk el, hogy Ctrl+C, Ctrl+V-t használunk, akkor érdemes megállni egy pillanatra és elgondolkozni azon, hogy ezt a funkcionalitást inkább kiszervezzük egy függvénybe, és ezután csak meghívjuk azt a megfelelő paraméterezéssel. Ha a másolt kódot egy picit írjuk át, az is duplikátumnak (klónnak) számít, amely ugyanúgy kiszervezhető egy közös függvénybe. (Clone Coverage)" maxScore="0.56498826" metricName="CC" name="Duplikált sorok aránya" score="0.6094928" weight="8.0"/><metric hint="Optimális esetben a programunk nem tartalmaz duplikátumokat, azonban ha mégis, akkor a legrosszabb, ami történhet, hogy ezek a lemásolt kódrészletek bonyolultak. Ezután ha az adott részen módosítani kell (ki kell egészíteni vagy hibát javítani), akkor az összes helyen el kell végezni a módosítást. Ha bonyolultak ezek a kódrészletek, akkor ez még több hibalehetőséget eredményez. (Clone Complexity)" maxScore="0.14124706" metricName="CCO" name="Duplikált sorok komplexitása" score="0.14218096" weight="2.0"/><metric hint="Optimális esetben a programunk nem tartalmaz duplikátumokat, azonban ha mégis, akkor nem mindegy, hogy mennyire nehéz azokat eltűntetni. Előbb-utóbb mindenképpen szükséges, de ha a program készítésekor nem figyeltünk eléggé, akkor a duplikátumokat úgy hoztuk létre, hogy azoknak a megszűntetése nem triviális. (Clone Elimination Effort)" maxScore="0.07062353" metricName="CEE" name="Duplikátumok eltűntetésének bonyolultsága" score="0.07106179" weight="1.0"/><metric hint="Minél több különböző duplikátum van, annál tovább tart őket eltűntetni, ezért célszerű ezt a számot minimalizálni. (Clone Classes)" maxScore="0.14124706" metricName="CCL" name="Különböző duplikátumok száma" score="0.1429981" weight="2.0"/><metric hint="Egy adott kódrészletet minél többször másoltunk le, annál több helyen kell átírni a kódot, ha valamilyen változást kell benne eszközölni. Célszerű a duplikátumok darabszámát minél alacsonyabban tartani a megegyező kódrészletek függvénybe való kiszervezésével. (Clone Instances)" maxScore="0.14124706" metricName="CI" name="Duplikátumok darabszáma" score="0.14340085" weight="2.0"/><metric hint="Ha a programban sok olyan sor van, ami egy duplikátum része, akkor sosem tudhatjuk, hogy az egyes duplikátumok módosításával mit értünk el, elfelejtettünk-e esetleg egy másik helyen is módosítani, stb. Célszerű ezért ezt a számot minél alacsonyabban tartani. (Logical Lines of Duplicated Code)" maxScore="0.14124706" metricName="LLDC" name="Duplikált sorok száma" score="0.14170015" weight="2.0"/></qualitygroup><qualitygroup groupMaxScore="1.1339" groupScore="1.1061653" name="Warningok" weight="17.0"><metric hint="Ügyeljünk a kivételkezelés megfelelő használatára, az eldobott és elkapott kivételek típusára. A kivételkezelést ne használjuk vezérlésre. Ügyeljünk a saját kivétel osztályok szabályos elkészítésére. (PMD)" maxScore="0.113390006" metricName="PMD_EXCEPT" name="Kivételkezeléssel kapcsolatos warningok" score="0.121789314" weight="1.0"/><metric hint="A kódban ne maradjanak felesleges kódelemek, mint például felesleges változók, adattagok, osztályok, importok, üres blokkok (if, for, stb.), ne csináljunk felesleges dolgokat (pl. adattagok default értékre való beállítása, egy osztály többszöri importálása, felesleges metódushívások, stb.). (PMD)" maxScore="0.113390006" metricName="PMD_UNNEC" name="Felesleges kódelemek" score="0.06869463" weight="1.0"/><metric hint="Mindig a megfelelő vezérlési szerkezetet érdemes használni. Pl. ha egy for ciklusban nem adunk meg sem inicializációs, sem inkrementáló részt, akkor igazából egy while ciklusunk van. Ha egy kollekciót járunk be, akkor érdemes foreach ciklust használni for helyett. Ügyeljünk a switchek megfelelő használatára: ne felejtsük el a break-eket és használjuk megfelelően a label-eket. (PMD)" maxScore="0.34017" metricName="PMD_CONTROL" name="Vezérlési szerkezetekkel kapcsolatos warningok" score="0.34017" weight="3.0"/><metric hint="A stringeket mindig a megfelelő módon hasonlítsuk össze és vigyázzunk rá, hogy lehet, hogy null az értékük. A kód újrafelhasználhatósága érdekében egy String csak egyszer forduljon elő a kódban. (PMD)" maxScore="0.113390006" metricName="PMD_STRING" name="Stringekkel kapacsolatos warningok" score="0.115119025" weight="1.0"/><metric hint="Ügyeljünk rá, hogy ne legyen olyan osztályunk, amit nem tudunk használni semmilyen módon. Ügyeljünk az absztrakt és final osztályokon belül a metódusokra és azok láthatóságára. Ahol lehet, használjunk polimorfizmust. (PMD)" maxScore="0.34017" metricName="PMD_CLASSES" name="Osztályokkal kapcsolatos warningok" score="0.34017" weight="3.0"/><metric hint="Figyeljünk oda a kódunk általános minőségére is és megfelelően készüljünk fel a várható hibákra. A gyors kiértékelést használjuk a megfelelő módon és ne bántsuk a JVM-et. (PMD)" maxScore="0.113390006" metricName="PMD_WOTHER" name="Egyéb warningok" score="0.120222375" weight="1.0"/></qualitygroup><qualitygroup groupMaxScore="0.46690002" groupScore="0.49520534" name="Antipatternek" weight="7.0"><metric hint="Előfordulhat objektumorientált programok esetében, hogy egy adott osztály végez minden funkcionalitást (God class). Mindenképpen célszerű ezeket elkerülni az osztály szétbontásával a különböző funkcionalitások mentén. Egy osztálynak egy feladata legyen. (Blob)" maxScore="0.12733637" metricName="Blob" name="Mindenható osztály" score="0.15917046" weight="3.0"/><metric hint="A hosszú és bonyolult függvényeket érdemes elkerülni a programunkban, mert nehezen átlátható kódot eredményeznek. Nem csak a kódsorok számára kell figyelni, hanem azok bonyolultságára is. Ha nagyon sok elágazás van egy függvényen belül, akkor az szintén ebbe a kategóriába esik. (LongFunction)" maxScore="0.12733637" metricName="LongFunction" name="Túl bonyolult függvény" score="0.10437408" weight="3.0"/><metric hint="Ha egy adott függvény többször használja más osztályok adattagjait és metódusait, mint a sajátjait, akkor vélhetően az a függvény rossz helyen van és érdemes áthelyezni oda, ahova funkcionalitása alapján tartozik. Egy metódus akkor esik bele ebbe a kategóriába, ha a belőle kiinduló hivatkozások nagy része nem a saját osztálya felé irányul. (featureEnvy)" maxScore="0.12733637" metricName="featureEnvy" name="Rosszul strukturált metódus" score="0.14459921" weight="3.0"/><metric hint="Érdemes elkerülni olyan eseteket, hogy egy adott (új) funkció hatására a programot sok különböző osztályban kelljen módosítani. Egy metódus akkor esik bele ebbe a kategóriába, ha nagyon sok helyről hivatkozzák. (shotgun)" maxScore="0.042445455" metricName="shotgun" name="Szétaprózódás" score="0.04286048" weight="1.0"/><metric hint="Ha egy gyerekosztály az ősosztálynak csak egy kis részét használja és egyébként nem sok közük van egymáshoz, akkor nem feltétlenül volt jó ötlet ebben a szituációban öröklődést használni. Az ilyen esetekben célszerű lehet a közös részt kiszervezni, és abból öröklődni mind a kettő osztálynak. (refusedBeq)" maxScore="0.042445455" metricName="refusedBeq" name="Felesleges öröklődés" score="0.04420113" weight="1.0"/></qualitygroup><qualitygroup groupMaxScore="0.2001" groupScore="0.1239546" name="Dokumentáció" weight="3.0"><metric hint="A publikus metódusokat (és az osztályokat) mindenképpen érdemes (értelmes és hasznos!) JavaDoc dokumentációval ellátni a könnyebb értelmezhetőség érdekében" maxScore="0.16675" metricName="TAD" name="Dokumentáció aránya" score="0.09052377" weight="5.0"/><metric hint="A dokumentációk készítése során érdemes ügyelni arra, hogy a dokumentáció teljes legyen (pl. ne legyenek megmagyarázatlan paraméterek, visszatérési értékek, stb.), továbbá a leírás formailag is tökéletes legyen. (checkstyle)" maxScore="0.033350002" metricName="STYLE_JAVADOC" name="Dokumentáció helyessége" score="0.033430826" weight="1.0"/></qualitygroup><qualitygroup groupMaxScore="0.3335" groupScore="0.35059237" name="Elnevezések" weight="5.0"><metric hint="Érdemes odafigyelni az osztályok megfelelő elnevezéseire, hogy könnyen megkülönböztethetőek legyenek. Az osztályok nevei nagy betűvel kezdődnek, majd minden szóhatáron nagy betű jön. (checkstyle)" maxScore="0.0416875" metricName="TYPE_NAMING" name="Osztályok és egyéb típusok elnevezései" score="0.043315932" weight="1.0"/><metric hint="Érdemes az adattagokat, függvény paramétereit és a lokális változókat a konvenciók szerint elnevezni, így azok könnyedén megkülönböztethetőek a többi programobjektumtól. Az adattagokat alapesetben camelCase jelöléssel hozzuk létre, kivétel a static final adattagok esetében, mert azokat csupa nagybetűvel írjuk. (checkstyle)" maxScore="0.083375" metricName="VARIABLE_NAMING" name="Adattagok és egyéb változók elnevezései" score="0.08544272" weight="2.0"/><metric hint="Érdemes a metódusokat a konvenciók szerint elnevezni, így azok könnyen megkülönböztethetők a többi programobjektumtól. A metódusok elnevezéséhez a camelCase jelölést használjuk. (checkstyle)" maxScore="0.083375" metricName="METHOD_NAMING" name="Metódusok elnevezései" score="0.08750729" weight="2.0"/><metric hint="A standard elnevezési szabályokon túl ügyeljünk rá, hogy a metódusokat és adattagokat ne nevezzük ugyanúgy, mint az osztályt, beszédes változóneveket és paraméter neveket használjunk. (PMD)" maxScore="0.1250625" metricName="PMD_NAMING" name="További elnevezéssel kapcsolatos szabályok" score="0.13432644" weight="3.0"/></qualitygroup><qualitygroup groupMaxScore="0.53360003" groupScore="0.50181234" name="Kódolási stílus" weight="8.0"><metric hint="A kapcsos zárójelek megfelelő elhelyezése nagyban segíti a programban való navigálást, így érdemes azokat a konvenciók szerint, konzisztensen használni. (checkstyle)" maxScore="0.10672001" metricName="STYLE_CURLY" name="Kapcsos zárójelek elhelyezkedése" score="0.086127765" weight="1.0"/><metric hint="Az indentáció az egyik legfontosabb a kód olvashatósága szempontjából. Ha rosszul van tagolva a programunk, akkor a kódunk nehezen olvashatóvá válik (még akkor is, ha egyébként maga a kód rendben van). (checkstyle)" maxScore="0.32016" metricName="STYLE_INDENTATION" name="Helyes indentáció, whitespace-ek" score="0.30739078" weight="3.0"/><metric hint="Ha egy sor nem fér ki a képernyőn, akkor az lassíthatja a kód olvasását. Éppen ezért célszerű a hosszú sorokat több külön sorba tördelni. (checkstyle)" maxScore="0.10672001" metricName="STYLE_LINES" name="Sorok hossza" score="0.108293846" weight="1.0"/></qualitygroup><qualitygroup groupMaxScore="0.4002" groupScore="0.32176042" name="Programkód szervezése" weight="6.0"><metric hint="Nem célszerű a programunkban felesleges pontosvesszőket hagyni, mert azok ronthatják a kód olvashatóságát. (checkstyle)" maxScore="0.044466667" metricName="CODING_SEMICOLONS" name="Felesleges pontosvesszők" score="0.0457476" weight="1.0"/><metric hint="Ha nagy a kódbázisunk, akkor több programkód van benne, tehát nem egyszerű feladat megtalálni amit éppen szeretnénk. Viszont ha konzisztensen készítjük az osztályainkat, és mindegyik osztály szerkezete hasonlóan néz ki, akkor ez jelentősen megkönnyíti a tájékozódást. Először hozzuk létre az adattagokat (láthatósági sorrendben), majd a konstruktorok, metódusok, végül a getterek, setterek és a toString következzen. (checkstyle)" maxScore="0.13340001" metricName="CODING_CLASSES" name="Osztályok szervezése" score="0.15371196" weight="3.0"/><metric hint="A kód szervezésére is érdemes hangsúlyt fektetni, például rövidebb lesz a programunk, ha minden utasítást egy sorba zsúfolunk, de az olvashatóságot ellehetetleníti. (checkstyle)" maxScore="0.044466667" metricName="CODING_BLOCKS" name="Kód szervezése" score="0.04506303" weight="1.0"/><metric hint="A mágikus számoknak nincs varázspálcájuk, de ettől még veszélyesek lehetnek. Ha a programunkban előbukkannak számok beégetve (pl. a &lt; 5), mindenféle magyarázat nélkül, akkor a programot később elolvasva már nem fogjuk érteni, hogy miért pont azok a számok kerültek oda, ráadásul a jelentésüket sem tudjuk. Ilyenkor érdemes egy konstans változóba kimenteni ezeket a számokat, így a változó nevéből következtetni tudunk arra, hogy az adott érték mit jelent, ezáltal a kód értelmezhetősége is javul. (checkstyle)" maxScore="0.044466667" metricName="CODING_NUMBERS" name="Mágikus számok" score="0.046149604" weight="1.0"/><metric hint="Egy adott probléma többféleképpen is megoldható, de az Occam borotvája elv alapján érdemes az egyszerűbbet választani. A programozásban is igaz ez, mert az egyszerűbb kód jobb átláthatóságot biztosít. Például ha egy feltétel alapján adunk vissza igazat vagy hamisat, akkor az helyettesíthető egyetlen return utasítással. (PMD)" maxScore="0.13340001" metricName="PMD_CODING" name="Kód átláthatósága" score="0.031088213" weight="3.0"/></qualitygroup><qualitygroup groupMaxScore="0.0" groupScore="NaN" name="Statisztika" weight="0.0"><metric hint="A teljes programban lévő osztályok darabszáma." maxScore="NaN" metricName="TNCL" name="Osztályok száma" score="NaN" weight="0.0"/><metric hint="A teljes programban lévő interface-ek darabszáma." maxScore="NaN" metricName="TNIN" name="Interface-ek száma" score="NaN" weight="0.0"/><metric hint="A teljes programban lévő enumok darabszáma." maxScore="NaN" metricName="TNEN" name="Enumok száma" score="NaN" weight="0.0"/><metric hint="A teljes program összes sorainak száma." maxScore="NaN" metricName="TLOC" name="Sorok száma" score="NaN" weight="0.0"/><metric hint="A teljes program tényleges sorainak száma (üres sorok, kommentek nem számítanak)." maxScore="NaN" metricName="TLLOC" name="Tényleges sorok száma" score="NaN" weight="0.0"/><metric hint="A teljes programban lévő adattagok darabszáma." maxScore="NaN" metricName="TNA" name="Adattagok száma" score="NaN" weight="0.0"/><metric hint="A teljes programban lévő metódusok darabszáma." maxScore="NaN" metricName="TNM" name="Metódusok száma" score="NaN" weight="0.0"/><metric hint="Program elkészítéséhez szükséges becsült idő (amely nem feltétlenül van összhangban a valósággal). Amennyiben azt tapasztaljuk, hogy a becsült idő jóval több a tényleges időnél, akkor vélhetően a programunk jelentős mennyiségű duplikációt tartalmaz." maxScore="NaN" metricName="HTRP" name="Becsült kódolási idő" score="NaN" weight="0.0"/></qualitygroup></results>